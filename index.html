<!DOCTYPE html>
<html>
    <head>
        <title>Precipitation at Maya sites</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <script type="text/javascript" src="http://mbostock.github.com/d3/d3.min.js"></script>
        <script type="text/javascript" src="http://mbostock.github.com/d3/d3.geo.min.js"></script>
        <script type="text/javascript" src="http://mbostock.github.com/d3/d3.layout.min.js"></script>
        <script type="text/javascript" src="http://code.jquery.com/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="https://raw.github.com/bigmlcom/tipsy/master/src/javascripts/jquery.tipsy.js"></script>
        <style type="text/css"> 
.tipsy {
  padding: 5px;
  position: absolute;
  z-index: 100000;
}

.tipsy-inner {
  padding: 5px 8px 4px 8px;
  background-color: #000;
  color: #eee;
  max-width: 200px;
  text-align: center;
}

.tipsy-inner {
  border-radius: 3px;
  -moz-border-radius:3px;
  -webkit-border-radius:3px;
}

.tipsy-arrow {
  position: absolute;
  width: 9px;
  height: 5px;
}

.tipsy-sw .tipsy-arrow { bottom: 0; left: 10px; }
.tipsy-se .tipsy-arrow { bottom: 0; right: 10px; }

body {
  font: 10px sans;
  fill: #222;
  text-rendering: optimizeLegibility;
}
text {
  font: 10px sans;
  fill: #222;
  text-rendering: optimizeLegibility;
}
text.axislabel {
    font-weight: bold;
}

rect {
  stroke: #222;
  stroke-width: 0.5;
}
rect.overlay {
  stroke: none;
  fill-opacity: 0;
}
rect.overlay:hover {
  stroke: #f00;
  stroke-width: 2;
}
rect.selected {
  stroke: #f00;
  stroke-width: 2;
}

path {
  stroke: #222;
  fill: none;
}

circle.site {
  stroke: #222;
  stroke-width: 1;
  fill: #222;
  shape-rendering: optimizeSpeed;
}
circle.site-selected {
  stroke: #f00;
  stroke-width: 3;
  fill: #f00;
  shape-rendering: optimizeSpeed;
}
        </style>
    </head>

    <body>
        <script type="text/javascript">
    (function() {
        var proj = d3.geo.mercator().scale(1).translate([0,0]),
            path = d3.geo.path().projection(proj).pointRadius(1),
            margin = 25, s = 30,
            width = window.innerWidth - margin,
            height = window.innerHeight - margin,
            numBins = 10, sSites = new Array(),
            svg = d3.select("body")
                .append("svg:svg")
                .attr("height", height)
                .attr("width", width),
            map = svg.append("svg:g"),
            sites = map.append("svg:g"),
            graph = svg.append("svg:g")
                .attr("transform", "translate(" +
                    (window.innerWidth - (4 * margin) - (numBins * s)) +
                    ", " + (2 * margin + 120) + ")"),
            glab = svg.append("svg:foreignObject")
                    .attr("width", 300)
                    .attr("height", 40)
                    .attr("transform", "translate(100,100)")
                    .append("div");

        function updateSelected(ele, d) {
            if(d.length > 0) {
                var idx = sSites.indexOf(d[0]);
                if(idx > -1) {
                    d3.select(ele).classed("selected", false);
                    sSites.splice(idx, d.length);
                } else {
                    d3.select(ele).classed("selected", true);
                    sSites = sSites.concat(d);
                }
                glab.html(sSites.length > 0 ?
                    sSites.length + " sites selected" :
                    "");
                var sel = sites.selectAll("circle").data(sSites,
                        function(e) {
                            return e.geometry.coordinates;
                        });
                sel.classed("site-selected", true);
                sel.exit().classed("site-selected", false);
            }
        }
        function resetLabel() {
            glab.html(sSites.length > 0 ?
                sSites.length + " sites selected" : "");
        }

        function setupHandlers(desc, limits, sites) {
            return function() {
                this.on("click", function(d) {
                        var thissites = $.map(d, function(e) { return e; });
                        updateSelected(this, thissites);
                    })
                    .on("mouseover", function(d, i) {
                        var smin = limits[0] + i * limits[1],
                            smax = limits[0] + (i + 1) * limits[1];
                        glab.html(d.length + " sites <br/>" +
                            desc[0] + " " + smin + " - " + smax + " " +
                            desc[1]);
                    })
                    .on("mouseout", resetLabel);
            }
        }

        function mkWOverlay(ele, eleo, data, callback, bcallback, ocallback) {
            ele.selectAll("rect")
                .data(data).enter()
                .append("svg:rect")
                .call(callback)
                .call(bcallback);
            eleo.selectAll("rect.overlay")
                .data(data).enter()
                .append("svg:rect")
                .attr("class", "overlay")
                .call(callback)
                .call(ocallback);
        }

        function mkGraph(descs, o) {
            var colour = d3.scale.pow().exponent(.2)
                        .domain([0, o.nmax]),
                cscales = [d3.scale.linear()
                            .domain([0, numBins-1])
                            .range(["#aaf", "#00f"]),
                           d3.scale.linear()
                            .domain([0, 100, 1000, 2000, 3000])
                            .range(["rgb(30, 120, 30)",
                                    "rgb(125, 125, 35)",
                                    "rgb(100, 25, 25)",
                                    "rgb(200, 200, 200)",
                                    "rgb(255, 255, 255)"])],
                hm = graph.append("svg:g"),
                hmrows = hm.selectAll("g")
                    .data(o.bins)
                    .enter().append("svg:g")
                    .property("row", function(d, i) { return i; })
                    .attr("transform", function(d, i) {
                            return "translate(0," + (s * i) + ")";
                        }),
                hmrowso = hm.selectAll("g.overlay")
                    .data(o.bins)
                    .enter().append("svg:g")
                    .attr("class", "overlay")
                    .property("row", function(d, i) { return i; })
                    .attr("transform", function(d, i) {
                            return "translate(0," + (s * i) + ")";
                        });
            mkWOverlay(hmrows, hmrowso, function(d) { return d; }, function() {
                this.attr("transform", function(d, i) {
                            return "translate(" + (s * i) + ",0)";
                        })
                    .attr("width", s)
                    .attr("height", s)
                return this;
            }, function() {
                this.attr("fill", function(d, col) {
                    var row = parseInt(d3.select(this.parentNode)
                            .property("row")),
                        rcolour = cscales[0](row),
                        ecolour = cscales[1](col * o.limits[1][1]),
                        blend = d3.scale.linear().range([rcolour, ecolour])(.5);
                    return colour.range(["white", blend])(d.length);
                });
            }, function() {
                this.on("click", function(d) {
                        updateSelected(this, d);
                    })
                    .on("mouseover", function(d, col) {
                        var row = parseInt(d3.select(d3.event.target.parentNode)
                                .property("row")),
                            rsmin = o.limits[0][0] + row * o.limits[0][1],
                            rsmax = o.limits[0][0] + (row + 1) * o.limits[0][1],
                            esmin = o.limits[1][0] + col * o.limits[1][1],
                            esmax = o.limits[1][0] + (col + 1) * o.limits[1][1];
                        glab.html(d.length + " sites <br/>" +
                            descs[0][0] + " " + rsmin + " - " + rsmax + " " +
                            descs[0][1] + "<br/>" + descs[1][0] + " " + esmin +
                            " - " + esmax + " " + descs[1][1]);
                    })
                    .on("mouseout", resetLabel);
            });
            // marginal distributions
            $.each(o.marginals, function(i, m) {
                var sscale = d3.scale.pow().exponent(.5)
                            .domain([0, o.maxs[i]])
                            .range([0, 100]),
                    me = graph.append("svg:g")
                            .attr("transform", function() {
                                return (i == 0 ? "translate(-35,0)" :
                                    "rotate(90)translate(-25,0)scale(1,-1)");
                            });
                mkWOverlay(me, me, m, function() {
                        this.attr("transform", function(d, j) {
                                return "translate(" + -sscale(d.length) + "," +
                                    s*j + ")";
                            })
                            .attr("width", function(d) {
                                return sscale(d.length);
                            })
                            .attr("height", s);
                        return this;
                    }, function() {
                        this.attr("fill", function(d, j) {
                                return (i == 0 ? cscales[i](j) : cscales[i](j *
                                    o.limits[i][1]));
                            });
                    },
                    setupHandlers(descs[i], o.limits[i], sites));
                // labels
                var dc = sscale(d3.max([m[numBins/2-1].length,
                            m[numBins/2].length, m[numBins/2+1].length])) + 10;
                me.append("svg:text")
                    .attr("transform", function() {
                            return "translate(" + -dc + "," + s*numBins/2 +
                                ")" + (i == 0 ? "" : "scale(1,-1)rotate(-90)");
                        })
                    .attr("text-anchor", function() {
                            return (i == 0 ? "end" : "middle");
                        })
                    .classed("axislabel", true)
                    .text(descs[i][0] + " [" + descs[i][1] + "]");
                for(var j = 0; j <= numBins; j++) {
                    me.append("svg:text")
                        .attr("transform", function() {
                                return "translate(" + 18 + "," + s*j + ")" +
                                    (i == 0 ? "" : "scale(1,-1)rotate(-90)");
                            })
                        .attr("text-anchor", "middle")
                        .attr("baseline-shift", function() {
                                return (i == 0 ? "-50%" : "0%");
                            })
                        .text(o.limits[i][0] + o.limits[i][1] * j);
                }
            });
        }

        function nsort(a, b) {
            return a - b;
        }
        function adjLims(min, max) {
            var tmp = Math.pow(10, ('' + max).length - 2),
                tmpmin = min - (min % tmp),
                tmpmax = max - (max % tmp) + tmp;
            return [tmpmin, tmpmax];
        }
        function mkMatrix(l) {
            m = new Array(l);
            for(var i = 0; i < l; i++) {
                m[i] = new Array(l);
                for(var j = 0; j < l; j++) {
                    m[i][j] = new Array();
                }
            }
            return m;
        }

        function mkMatrixRe(l, i) {
            if(i > 0) {
                var m = new Array(l);
                for(var j = 0; j < l; j++) {
                    m[j] = mkMatrixRe(l, i-1);
                }
                return m;
            } else {
                return [];
            }
        }

        function assignBinRe(d, bins, marginals, limits, funcs, i) {
            if(i < funcs.length) {
                var nbin = Math.floor((funcs[i](d) -
                        limits[i][0]) / limits[i][1]);
                marginals[i][nbin].push(d);
                assignBinRe(d, bins[nbin], marginals, limits, funcs, i+1);
            } else {
                bins.push(d);
            }
        }

        function getMaxRe(a) {
            if(a[0] instanceof Array) {
                return d3.max($.map(a, function(b) {
                            return getMaxRe(b);
                        }));
            } else {
                return a.length;
            }
        }

        function bin(raw) {
            if(arguments.length < 2) { return null; }
            var args = [], limits = [], o = new Object();
            for(var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            $.each(args, function(i, f) {
                var data = $.map(raw, function(d) {
                            return f(d);
                        }).sort(nsort),
                    tmp = adjLims(data[0], data[data.length-1]),
                    dmin = tmp[0], dmax = tmp[1],
                    delta = (dmax - dmin) / numBins;
                limits.push([dmin, delta, dmax]);
            });

            var bins = mkMatrixRe(numBins, args.length),
                marginals = new Array(args.length);
            for(var i = 0; i < marginals.length; i++) {
                marginals[i] = mkMatrixRe(numBins, 1);
            }

            $.each(raw, function(i, d) {
                assignBinRe(d, bins, marginals, limits, args, 0);
            });

            var maxs = new Array(marginals.length);
            for(var i = 0; i < marginals.length; i++) {
                maxs[i] = getMaxRe(marginals[0]);
            }

            o.bins = bins;
            o.marginals = marginals;
            o.limits = limits;
            o.nmax = getMaxRe(bins);
            o.maxs = maxs;
            return o;
        }

        d3.json("mesoamerica.geojson", function(json) {
            var bounds0 = d3.geo.bounds(json),
                bounds = bounds0.map(proj),
                xscale = width/Math.abs(bounds[1][0] - bounds[0][0]),
                yscale = height/Math.abs(bounds[1][1] - bounds[0][1]),
                scale = Math.min(xscale, yscale);

            proj.scale(scale);
            proj.translate(proj([-bounds0[0][0], -bounds0[1][1]]));

            map.append("svg:g").selectAll("path")
                .data(json.features)
                .enter().append("svg:path")
                .attr("d", path);
            d3.json("rain-ele.geojson", function(json) {
                var descs = [["precipitation", "l/m²"], ["elevation", "m"]],
                    rainf = function(d) { return d.properties["rain-year"]; },
                    elef = function(d) { return d.properties["elevation"]; };
                sites.selectAll("circle")
                    .data(json.features)
                    .enter().append("svg:circle")
                    .attr("r", function(d) {
                            return Math.max(1, 4 - d.properties.rank);
                        })
                    .attr("cx", function(d) {
                            return proj(d.geometry.coordinates)[0];
                        })
                    .attr("cy", function(d) {
                            return proj(d.geometry.coordinates)[1];
                        })
                    .classed("site", true)
                    .append("original-title").text(function(d) {
                        if(proj(d.geometry.coordinates)[0] > width/2) {
                            $(this).parent().tipsy({gravity:'se'});
                        } else {
                            $(this).parent().tipsy({gravity:'sw'});
                        }
                        return d.properties.name + ": " +
                            rainf(d) + " " + descs[0][1] + ", " +
                            elef(d) + " " + descs[1][1];
                    });

                mkGraph(descs, bin(json.features, rainf, elef));
            });
        });
    })();
        </script>
    </body>
</html>
